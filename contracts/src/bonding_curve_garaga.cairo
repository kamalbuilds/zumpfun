// SPDX-License-Identifier: MIT
// ZumpFun Bonding Curve Contract - Garaga Integration
// Complete integration of Garaga ZK proof verification

use starknet::ContractAddress;

// Import Garaga verifier interface (generated by garaga gen command)
use contribution_verifier::IUltraStarknetZKHonkVerifierDispatcher;
use contribution_verifier::IUltraStarknetZKHonkVerifierDispatcherTrait;

/// This file shows the complete Garaga integration for bonding_curve.cairo
/// Replace the TODO markers in bonding_curve.cairo with this code

/// Integration for buy() function (Line 303)
/// Replaces: // TODO: Verify payment_proof using Garaga
fn verify_contribution_proof(
    self: @ContractState,
    payment_proof: Span<felt252>,
    commitment: felt252,
    amount: u256,
) {
    // 1. Get the verifier dispatcher
    let verifier = IUltraStarknetZKHonkVerifierDispatcher {
        contract_address: self.contribution_verifier.read()
    };

    // 2. Verify the proof using Garaga Ultra Honk verifier
    // Returns Some(public_inputs) if valid, None if invalid
    let result = verifier.verify_ultra_starknet_zk_honk_proof(payment_proof);

    // 3. Assert proof is valid
    assert(result.is_some(), 'Invalid contribution proof');

    // 4. Extract and validate public inputs from the proof
    let public_inputs = result.unwrap();

    // The contribution circuit has 3 public inputs:
    // - public_inputs[0]: commitment (Pedersen commitment to amount)
    // - public_inputs[1]: min_amount (minimum contribution allowed)
    // - public_inputs[2]: max_amount (maximum contribution allowed)
    assert(public_inputs.len() >= 3, 'Missing public inputs');

    let proof_commitment = *public_inputs.at(0);
    let proof_min = *public_inputs.at(1);
    let proof_max = *public_inputs.at(2);

    // 5. Verify the commitment matches what was provided
    assert(proof_commitment == commitment, 'Commitment mismatch');

    // 6. Verify amount is within the bounds proven in the ZK proof
    let amount_felt: felt252 = amount.try_into().unwrap();
    assert(proof_min <= amount_felt, 'Amount below proven minimum');
    assert(proof_max >= amount_felt, 'Amount above proven maximum');

    // 7. Verify the amount matches trading parameters
    let params = self.trading_params.read();
    assert(amount >= params.min_buy_amount, 'Amount below contract minimum');
    assert(amount <= params.max_buy_per_tx, 'Amount exceeds max per tx');
}

/// Integration for sell() function (Line 353)
/// Replaces: // TODO: Verify sell_proof using Garaga
fn verify_sell_proof(
    self: @ContractState,
    sell_proof: Span<felt252>,
    amount: u256,
    nullifier: felt252,
) {
    // 1. Get the verifier dispatcher (same verifier for contribution proofs)
    let verifier = IUltraStarknetZKHonkVerifierDispatcher {
        contract_address: self.contribution_verifier.read()
    };

    // 2. Verify the sell proof
    let result = verifier.verify_ultra_starknet_zk_honk_proof(sell_proof);
    assert(result.is_some(), 'Invalid sell proof');

    // 3. Extract public inputs
    let public_inputs = result.unwrap();

    // The sell proof has 2 public inputs:
    // - public_inputs[0]: nullifier (prevents double-spending)
    // - public_inputs[1]: amount (amount being sold)
    assert(public_inputs.len() >= 2, 'Missing public inputs');

    let proof_nullifier = *public_inputs.at(0);
    let proof_amount = *public_inputs.at(1);

    // 4. Verify nullifier matches
    assert(proof_nullifier == nullifier, 'Nullifier mismatch');

    // 5. Verify amount matches
    let amount_felt: felt252 = amount.try_into().unwrap();
    assert(proof_amount == amount_felt, 'Amount mismatch');

    // 6. Verify nullifier hasn't been used (prevent double-spending)
    assert(!self.used_nullifiers.read(nullifier), 'Nullifier already used');
}

/// Storage additions needed for Garaga integration
/// Add these to the Storage struct in bonding_curve.cairo:
///
/// ```cairo
/// #[storage]
/// struct Storage {
///     // ... existing storage ...
///
///     /// Garaga verifier for contribution proofs
///     contribution_verifier: ContractAddress,
/// }
/// ```

/// Constructor additions needed
/// Add this parameter to the constructor in bonding_curve.cairo:
///
/// ```cairo
/// #[constructor]
/// fn constructor(
///     ref self: ContractState,
///     // ... existing parameters ...
///     contribution_verifier: ContractAddress,  // Add this
/// ) {
///     // ... existing initialization ...
///
///     // Add this initialization
///     self.contribution_verifier.write(contribution_verifier);
/// }
/// ```

/// Complete buy() function with Garaga integration
/// Replace the entire buy() function in bonding_curve.cairo:
pub fn buy_with_garaga(
    ref self: ContractState,
    amount: u256,
    payment_proof: Span<felt252>,
    commitment: felt252,
) -> felt252 {
    // Check not graduated
    assert!(!self.graduated.read(), "Already graduated to AMM");

    // Validate amount
    let params = self.trading_params.read();
    assert!(amount >= params.min_buy_amount, "Amount too small");
    assert!(amount <= params.max_buy_per_tx, "Amount exceeds max per tx");

    // Check supply limit
    let current_supply = self.current_supply.read();
    let graduation_threshold = self.graduation_threshold.read();
    assert!(current_supply + amount <= graduation_threshold, "Exceeds graduation supply");

    // Calculate cost including fees
    let base_cost = self.calculate_buy_price(amount);
    let total_fee_bps = params.trading_fee_bps;
    let fees = (base_cost * total_fee_bps.into()) / 10000;
    let total_cost = base_cost + fees;

    // ⚡ GARAGA VERIFICATION - Replaces TODO at line 303
    verify_contribution_proof(@self, payment_proof, commitment, amount);

    // Check commitment not already used
    assert!(!self.commitments.read(commitment), "Commitment already used");
    self.commitments.write(commitment, true);

    // Update state
    self.current_supply.write(current_supply + amount);
    self.total_raised.write(self.total_raised.read() + base_cost);

    // Allocate fees
    let creator_fee = (fees * params.creator_fee_bps.into()) / total_fee_bps.into();
    let protocol_fee = fees - creator_fee;
    self.creator_fees.write(self.creator_fees.read() + creator_fee);
    self.protocol_fees.write(self.protocol_fees.read() + protocol_fee);

    // Emit event
    self.emit(
        TokensBought {
            commitment,
            amount,
            cost: total_cost,
            new_supply: current_supply + amount,
            timestamp: get_block_timestamp(),
        }
    );

    // Return new balance commitment (encrypted)
    commitment
}

/// Complete sell() function with Garaga integration
/// Replace the entire sell() function in bonding_curve.cairo:
pub fn sell_with_garaga(
    ref self: ContractState,
    amount: u256,
    sell_proof: Span<felt252>,
    nullifier: felt252,
) -> felt252 {
    // Check not graduated
    assert!(!self.graduated.read(), "Already graduated to AMM");

    // ⚡ GARAGA VERIFICATION - Replaces TODO at line 353
    verify_sell_proof(@self, sell_proof, amount, nullifier);

    // Calculate return amount
    let return_amount = self.calculate_sell_price(amount);

    // Mark nullifier as used
    self.used_nullifiers.write(nullifier, true);

    // Update state
    let current_supply = self.current_supply.read();
    self.current_supply.write(current_supply - amount);
    self.total_raised.write(self.total_raised.read() - return_amount);

    // Emit event
    self.emit(
        TokensSold {
            nullifier,
            amount,
            return_amount,
            new_supply: current_supply - amount,
            timestamp: get_block_timestamp(),
        }
    );

    // Return new balance commitment (would be computed by frontend)
    nullifier // Placeholder
}

/// Gas Optimization Tips:
///
/// 1. Cache verifier dispatcher if calling multiple times
/// 2. Batch multiple proof verifications in a single transaction
/// 3. Use memory-efficient proof encoding from Garaga SDK
/// 4. Consider proof aggregation for multiple buys/sells

/// Security Considerations:
///
/// 1. Always check nullifiers before marking as used
/// 2. Verify commitment uniqueness before storing
/// 3. Ensure public inputs from proof match function parameters
/// 4. Use try_into().unwrap() carefully with proper assertions
/// 5. Consider rate limiting to prevent spam attacks

/// Testing Example:
///
/// ```cairo
/// #[test]
/// fn test_buy_with_garaga_proof() {
///     // Setup
///     let contribution_verifier = deploy_contribution_verifier();
///     let bonding_curve = deploy_bonding_curve(contribution_verifier);
///
///     // Generate proof (from Noir circuit)
///     let amount = 1_000_000_000_000_000_000; // 1 ETH
///     let blinding = 0x1234567890abcdef;
///     let commitment = pedersen_commit(amount, blinding);
///
///     // Generate proof using Noir + Barretenberg
///     let proof = generate_contribution_proof(amount, blinding, MIN_AMOUNT, MAX_AMOUNT);
///
///     // Encode for Cairo using Garaga SDK
///     let encoded_proof = garaga_encode_proof(proof);
///
///     // Call buy
///     let result = bonding_curve.buy(amount, encoded_proof, commitment);
///
///     // Verify success
///     assert(result == commitment, 'Buy failed');
/// }
/// ```
